<script src="resources/node_modules/jquery/dist/jquery.min.js"></script>

<script src="resources/sigma.min.js"></script>
<script src="resources/sigma.canvas.edgehovers.def.js"></script>
<script src="resources/sigma.renderers.edgeLabels.min.js"></script>

<script src="clickFunctionality.js"></script>

<script src="algorithms/dijkstra.js"></script>
<script src="algorithms/prims.js"></script>
<script src="algorithms/kruskal.js"></script>

<script src="resources/Tree.js"></script>

<html>
<head>
    <title>Eman's Graph Tool</title>
</head>

<body id="base">

<div>
    Source Node:<br>
    <input id="srcNode"><br>
    Dest Node:<br>
    <input id="destNode"><br>
</div>

<br>
<div>
    <button onclick="loadNodeLayoutTemplate1()">Node Setup 1</button>
</div>

<div>
    <button onclick="createRandomGraph(10)">Random Graph</button>
</div>

<div>
    <button onclick="loadFreeMode()">Load free mode</button>
</div>
<br>
<div>
    <button onclick="calculateDijkstraPath()">Run Dijkstra's</button>
</div>

<div>
    <button onclick="calculatePrimsPath()">Run Prim's</button>
</div>

<div>
    <button onclick="calculateKruskalPath()">Run Kruskal's</button>
</div>
<br>
<div>
    <button onclick="clearGraph()">CLEAR GRAPH</button>
</div>

<script>

    const s = new sigma({
        renderer: {
            container: document.getElementById('base'),
            type: 'canvas'
        },
        settings: {
            borderSize: 3,

            defaultNodeBorderColor: "#c9ddff",
            defaultEdgeLabelSize: 20,

            defaultLabelHoverColor: "#FFFFFF",
            labelHoverColor: "node",
            labelShadowColor: "#c9ddff",

            enableEdgeHovering: true,
            edgeHoverSizeRatio: 2,
            edgeHoverExtremities: true,
            autoRescale: localStorage.getItem("autoRescale") === "true",
            mouseEnabled: localStorage.getItem("mouseEnabled") === "true"
        }
    });

    $(document).bind("contextmenu", function (event) {
        event.preventDefault();
    });

    $('#base').dblclick(function (e) {
        e.stopPropagation();
    });

    window.onload = function () {
        const storageNodes = JSON.parse(localStorage.getItem("nodes"));
        const storageEdges = JSON.parse(localStorage.getItem("edges"));

        if (storageNodes.length > 0) {
            storageNodes.forEach(function (node) {
                s.graph.addNode(node);
            });

            if (storageEdges.length > 0) {
                storageEdges.forEach(function (edge) {
                    s.graph.addEdge(edge);
                });
            }
            s.refresh();
        }
    };

    window.onbeforeunload = function () {
        clearColoredNodesAndEdges();

        localStorage.clear();

        localStorage.setItem("nodes", JSON.stringify(s.graph.nodes()));
        localStorage.setItem("edges", JSON.stringify(s.graph.edges()));

        localStorage.setItem("autoRescale", s.settings("autoRescale"));
        localStorage.setItem("mouseEnabled", s.settings("mouseEnabled"));
    };

    function loadFreeMode() {
        s.settings('autoRescale', false);
        s.settings('mouseEnabled', true);

        clearGraph();
    }

    function loadNodeLayoutTemplate1() {
        clearGraph();

        s.settings('autoRescale', true);
        s.settings('mouseEnabled', false);

        let id = 0;

        for (let i = 0; i < 10; i++) {
            for (let j = 0; j < 10; j++) {
                if (i !== 5 || j < 2 || j > 7) {
                    s.graph.addNode({
                        id: createNodeIdFromCoordinates(i, j),
                        label: (id++).toString(),
                        x: i,
                        y: j,
                        size: 3
                    });

                    if (s.graph.nodes(createNodeIdFromCoordinates(i - 1, j))) {
                        s.graph.addEdge({
                            id: createEdgeIdFromCoordinates(createNodeIdFromCoordinates(i - 1, j), createNodeIdFromCoordinates(i, j)),
                            source: createNodeIdFromCoordinates(i - 1, j),
                            target: createNodeIdFromCoordinates(i, j),
                            label: "5",
                            size: 5
                        });
                    }

                    if (s.graph.nodes(createNodeIdFromCoordinates(i, j - 1))) {
                        s.graph.addEdge({
                            id: createEdgeIdFromCoordinates(createNodeIdFromCoordinates(i, j - 1), createNodeIdFromCoordinates(i, j)),
                            source: createNodeIdFromCoordinates(i, j - 1),
                            target: createNodeIdFromCoordinates(i, j),
                            label: "5",
                            size: 5
                        });
                    }

                    if (i % 2 === 0 && j % 2 === 0 && s.graph.nodes(createNodeIdFromCoordinates(i - 1, j - 1))) {
                        s.graph.addEdge({
                            id: createEdgeIdFromCoordinates(createNodeIdFromCoordinates(i - 1, j - 1), createNodeIdFromCoordinates(i, j)),
                            source: createNodeIdFromCoordinates(i - 1, j - 1),
                            target: createNodeIdFromCoordinates(i, j),
                            label: "5",
                            size: 5
                        });
                    }
                }
            }
        }
        s.refresh();
    }

    function createRandomGraph(nodeAmount) {
        clearGraph();

        s.settings('autoRescale', true);
        s.settings('mouseEnabled', false);

        let id = 0;

        for (let i = 0; i < nodeAmount; i++) {

            const generatedX = Math.floor((Math.random() * 50));
            const generatedY = Math.floor((Math.random() * 50));

            s.graph.addNode({
                id: createNodeIdFromCoordinates(generatedX, generatedY),
                label: (id++).toString(),
                x: generatedX,
                y: generatedY,
                size: 3
            })
        }

        const nodeOnGraph = s.graph.nodes();

        const edgeIdSet = new Set();

        for (let node of s.graph.nodes()) {
            const pickRandomNodeToConnect = Math.floor(Math.random() * nodeOnGraph.length);

            const sourceNode = node;
            const destNode = nodeOnGraph[pickRandomNodeToConnect];

            if (sourceNode === destNode) {
                continue;
            }

            const edgeId = createEdgeIdFromCoordinates(sourceNode.id, destNode.id);

            if (!edgeIdSet.has(edgeId)) {
                s.graph.addEdge({
                    id: edgeId,
                    source: sourceNode.id,
                    target: destNode.id,
                    defaultEdgeLabelSize: 20,
                    size: 3,
                    label: computePathLength(sourceNode, destNode).toString()
                });

                edgeIdSet.add(edgeId);
            }
        }
        s.refresh();
    }

    function calculateDijkstraPath() {
        clearColoredNodesAndEdges();

        const srcNodeColour = "#001299";
        const destNodeColour = "#991600";
        const pathColour = "#6e0db6";

        const srcNodeId = getNodeIdFromLabel($("#srcNode").val());
        const destNodeId = getNodeIdFromLabel($("#destNode").val());

        s.graph.nodes(srcNodeId).color = srcNodeColour;
        s.graph.nodes(destNodeId).color = destNodeColour;

        const path = s.graph.dijkstra(srcNodeId, destNodeId);

        if (path) {
            for (let i = 0; i < path.length; i++) {

                (function (index) {
                    setTimeout(function () {
                        path[index].color = pathColour;
                        s.refresh();
                    }, i * 2000)
                })(i);
            }
        } else {
            alert("NO PATH");
        }
    }

    function calculatePrimsPath() {
        clearColoredNodesAndEdges();

        const srcNodeId = getNodeIdFromLabel($("#srcNode").val());

        const path = s.graph.prims(srcNodeId);

        if (path) {
            for (let i = 0; i < path.length; i++) {

                (function (index) {
                    setTimeout(function () {
                        path[index].color = "#6e0db6";
                        s.refresh();
                    }, i * 2000)
                })(i);
            }
        } else {
            alert("NO PATH");
        }
    }

    function calculateKruskalPath() {
        clearColoredNodesAndEdges();

        const path = s.graph.kruskal();

        if (path) {
            for (let i = 0; i < path.length; i++) {

                (function (index) {
                    setTimeout(function () {
                        s.graph.edges(path[index]).color = "#6e0db6";
                        s.refresh();
                    }, i * 2000)
                })(i);
            }
        } else {
            alert("NO PATH");
        }
    }

    function clearGraph() {
        s.graph.clear();
        localStorage.clear();
        s.refresh();
    }

    function clearColoredNodesAndEdges() {
        s.graph.nodes().forEach(function (node) {
            node.color = "#000000"
        });

        s.graph.edges().forEach(function (edges) {
            edges.color = "#000000"
        });

        s.refresh();
    }

    function getNodeIdFromLabel(nodeId) {
        return s.graph.nodes().filter(function (node) {
            return node.label === nodeId
        }).shift().id;
    }

    const createNodeIdFromCoordinates = function (x, y) {
        return x + '.' + y;
    };

    function createEdgeIdFromCoordinates(x, y) {
        return x + "|" + y;
    }

    function computePathLength(node1, node2) {
        return (Math.sqrt(Math.pow((node2.y - node1.y), 2) + Math.pow((node2.x - node1.x), 2)) / 10).toFixed(2);
    }

</script>
</body>
</html>
