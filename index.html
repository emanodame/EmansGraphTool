<script src="resources/node_modules/jquery/dist/jquery.min.js"></script>

<script src="resources/sigma.min.js"></script>
<script src="resources/sigma.canvas.edgehovers.def.js"></script>
<script src="resources/sigma.renderers.edgeLabels.min.js"></script>

<script src="clickFunctionality.js"></script>

<script src="algorithms/dijkstra.js"></script>
<script src="algorithms/prims.js"></script>
<script src="algorithms/kruskal.js"></script>

<script src="teachers/dijsktraTeacher.js"></script>
<script src="teachers/primsTeacher.js"></script>
<script src="teachers/kruskalTeacher.js"></script>

<script src="tools/Tree.js"></script>
<script src="tools/Timer.js"></script>


<html>
<head>
    <title>Eman's Graph Tool</title>
</head>

<body id="base">

<div>
    Source Node:<br>
    <input id="srcNode"><br>
    Target Node:<br>
    <input id="targetNode"><br>
</div>

<br>
<div>
    <button onclick="loadPreDefinedNodeLayoutTemplate1()">Node Setup 1</button>
</div>

<div>
    <button onclick="createRandomGraph(20)">Random Graph</button>
</div>

<div>
    <button onclick="loadFreeMode()">Load free mode</button>
</div>
<br>
<div>
    <button onclick="calculateDijkstraPath()">Run Dijkstra's</button>
</div>

<div>
    <button onclick="calculatePrimsPath()">Run Prim's</button>
</div>

<div>
    <button onclick="calculateKruskalPath()">Run Kruskal's</button>
</div>
<br>
<div>
    <button onclick="clearGraph()">CLEAR GRAPH</button>
</div>
<br>
<div>
    <button id="pauseResumeBtn">PAUSE</button>
</div>

<script>

    const s = new sigma({
        renderer: {
            container: document.getElementById('base'),
            type: 'canvas'
        },
        settings: {
            borderSize: 3,

            defaultNodeBorderColor: "#c9ddff",
            defaultEdgeLabelSize: 20,

            defaultLabelHoverColor: "#FFFFFF",
            labelHoverColor: "node",
            labelShadowColor: "#c9ddff",

            enableEdgeHovering: true,
            edgeHoverSizeRatio: 2,
            edgeHoverExtremities: true,
            autoRescale: localStorage.getItem("autoRescale") === "true",
            mouseEnabled: localStorage.getItem("mouseEnabled") === "true"
        }
    });

    $(document).bind("contextmenu", function (event) {
        event.preventDefault();
    });

    $('#base').dblclick(function (e) {
        e.stopPropagation();
    });

    window.onload = function () {
        const storageNodes = JSON.parse(localStorage.getItem("nodes"));
        const storageEdges = JSON.parse(localStorage.getItem("edges"));

        if (storageNodes.length > 0) {
            storageNodes.forEach(function (node) {
                s.graph.addNode(node);
            });

            if (storageEdges.length > 0) {
                storageEdges.forEach(function (edge) {
                    s.graph.addEdge(edge);
                });
            }
            s.refresh();
        }
    };

    window.onbeforeunload = function () {
        clearColoredNodesAndEdges();
        localStorage.clear();

        localStorage.setItem("nodes", JSON.stringify(s.graph.nodes()));
        localStorage.setItem("edges", JSON.stringify(s.graph.edges()));

        localStorage.setItem("autoRescale", s.settings("autoRescale"));
        localStorage.setItem("mouseEnabled", s.settings("mouseEnabled"));
    };

    $("#pauseResumeBtn").click(function () {
        if ($(this).text() === 'PAUSE') {
            pauseTimer();
            $(this).text('RESUME');
        } else {
            resumeTimer();
            $(this).text('PAUSE');
        }
    });

    function loadFreeMode() {
        s.settings('autoRescale', false);
        s.settings('mouseEnabled', true);

        clearGraph();
    }

    function loadPreDefinedNodeLayoutTemplate1() {
        clearGraph();

        s.settings('autoRescale', true);
        s.settings('mouseEnabled', false);

        let labelId = 0;

        for (let i = 0; i < 10; i++) {
            for (let j = 0; j < 10; j++) {
                if (i !== 5 || j < 2 || j > 7) {
                    s.graph.addNode({
                        id: createNodeIdFromCoordinates(i, j),
                        label: (labelId++).toString(),
                        x: i,
                        y: j,
                        size: 3
                    });

                    if (s.graph.nodes(createNodeIdFromCoordinates(i - 1, j))) {
                        s.graph.addEdge({
                            id: createEdgeIdFromCoordinates(createNodeIdFromCoordinates(i - 1, j), createNodeIdFromCoordinates(i, j)),
                            source: createNodeIdFromCoordinates(i - 1, j),
                            target: createNodeIdFromCoordinates(i, j),
                            label: "5",
                            size: 5
                        });
                    }

                    if (s.graph.nodes(createNodeIdFromCoordinates(i, j - 1))) {
                        s.graph.addEdge({
                            id: createEdgeIdFromCoordinates(createNodeIdFromCoordinates(i, j - 1), createNodeIdFromCoordinates(i, j)),
                            source: createNodeIdFromCoordinates(i, j - 1),
                            target: createNodeIdFromCoordinates(i, j),
                            label: "5",
                            size: 5
                        });
                    }

                    if (i % 2 === 0 && j % 2 === 0 && s.graph.nodes(createNodeIdFromCoordinates(i - 1, j - 1))) {
                        s.graph.addEdge({
                            id: createEdgeIdFromCoordinates(createNodeIdFromCoordinates(i - 1, j - 1), createNodeIdFromCoordinates(i, j)),
                            source: createNodeIdFromCoordinates(i - 1, j - 1),
                            target: createNodeIdFromCoordinates(i, j),
                            label: "5",
                            size: 5
                        });
                    }
                }
            }
        }
        s.refresh();
    }

    function createRandomGraph(quantityOfNodes) {
        clearGraph();

        s.settings('autoRescale', true);
        s.settings('mouseEnabled', false);

        let labelId = 0;

        const nodeIdSet = new Set();

        for (let i = 0; i < quantityOfNodes; i++) {

            const randomGeneratedX = Math.floor((Math.random() * 50));
            const randomGeneratedY = Math.floor((Math.random() * 50));

            const nodeId = createNodeIdFromCoordinates(randomGeneratedX, randomGeneratedY);

            if (!nodeIdSet.has(nodeId)) {
                s.graph.addNode({
                    id: createNodeIdFromCoordinates(randomGeneratedX, randomGeneratedY),
                    label: (labelId++).toString(),
                    x: randomGeneratedX,
                    y: randomGeneratedY,
                    size: 3
                });

                nodeIdSet.add(nodeId);
            }
        }

        const nodesOnGraph = s.graph.nodes();

        const edgeIdSet = new Set();

        for (let node of nodesOnGraph) {
            const pickRandomNodeToConnect = Math.floor(Math.random() * nodesOnGraph.length);

            const sourceNode = node;
            let targetNode = nodesOnGraph[pickRandomNodeToConnect];

            while (sourceNode === targetNode) {
                targetNode = nodesOnGraph[Math.floor(Math.random() * nodesOnGraph.length)];
            }

            const edgeId = createEdgeIdFromCoordinates(sourceNode.id, targetNode.id);

            if (!edgeIdSet.has(edgeId)) {
                s.graph.addEdge({
                    id: edgeId,
                    source: sourceNode.id,
                    target: targetNode.id,
                    defaultEdgeLabelSize: 20,
                    size: 3,
                    label: computePathLength(sourceNode, targetNode).toString()
                });

                edgeIdSet.add(edgeId);
            }
        }
        s.refresh();
    }

    function calculateDijkstraPath() {
        clearColoredNodesAndEdges();

        const srcNodeColour = "#001299";
        const srcNodeId = getNodeIdFromLabel($("#srcNode").val());

        s.graph.nodes(srcNodeId).color = srcNodeColour;

        const path = s.graph.dijkstra(srcNodeId);
        executeDijkstraTeacher(path);
    }

    function calculatePrimsPath() {
        clearColoredNodesAndEdges();

        const srcNodeId = getNodeIdFromLabel($("#srcNode").val());

        const edgesWithMinSpanTreeFlag = s.graph.prims(srcNodeId);
        executePrimsTeacher(edgesWithMinSpanTreeFlag);
    }

    function calculateKruskalPath() {
        clearColoredNodesAndEdges();

        const idsOfMinSpanningTreeEdges = s.graph.kruskal();
        executeKruskalTeacher(idsOfMinSpanningTreeEdges);
    }

    function clearGraph() {
        s.graph.clear();
        localStorage.clear();
        s.refresh();
    }

    function clearColoredNodesAndEdges() {
        s.graph.nodes().forEach(function (node) {
            node.color = "#000000"
        });

        s.graph.edges().forEach(function (edges) {
            edges.color = "#000000"
        });

        s.refresh();
    }

    function getNodeIdFromLabel(nodeId) {
        return s.graph.nodes().filter(function (node) {
            return node.label === nodeId
        }).shift().id;
    }

    const createNodeIdFromCoordinates = function (x, y) {
        return x + '.' + y;
    };

    function createEdgeIdFromCoordinates(x, y) {
        return x + "|" + y;
    }

    function computePathLength(node1, node2) {
        return (Math.sqrt(Math.pow((node2.y - node1.y), 2) + Math.pow((node2.x - node1.x), 2)) / 10).toFixed(2);
    }

    function returnSortedEdgesByWeight() {
        return s.graph.edges().sort(function (a, b) {
            return a.label - b.label;
        });
    }
</script>
</body>
</html>